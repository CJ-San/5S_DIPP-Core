//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /afs/asu.edu/users/c/j/s/cjsando1/EEE_498/HW_4/EEE498_NOV_26/ProjPart4/rtl/combCore.vp
//  Source template: combCore
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

// combCore.vp
// bitWidth (_GENESIS2_DECLARATION_PRIORITY_) = 32
//
module combCore (
	input  logic [31:0] instr,
	input  logic [31:0] pc,
	input  logic [31:0] src0,
	input  logic [31:0] src1,
	input  logic [31:0] memRdData,
	output logic [31:0] memRdAddr,
	output logic             memRdEn,
	output logic [31:0] memWrData ,
	output logic [31:0] memWrAddr,
	output logic             memWrEn ,
	output logic [31:0] dst0,
	output logic [31:0] pcNxt
);

 	logic [31:0]     instr_se;
 	logic [27:0]     instr_jump;
 	logic [31:0]     instr_se_sl2;
 	logic [31:0]     pc_4;
 	logic [31:0]     pc_jr;
 	logic [31:0]     pc_jump, pc_branch;
 	logic [31:0]     pc_nxt0;
 	logic [31:0]     alusrc1;
 	logic [31:0]     ALUout;
 	logic                 ALUSrc;
 	logic [1:0]           jump_sel;
 	logic                 branch_en;
 	logic                 branch;
 	logic                 RegDST;
 	logic [4:0]           RegDST_out;
 	logic                 memRead;
 	logic                 mem_to_reg;
 	logic                 memWrite;
 	logic                 RegWrite;
 	logic [5:0]           ALUop;
	logic [5:0]           opcode;


////////////////////////////////////
// D Instatiations 
////////////////////////////////////



ALU_unq1  my_ALU  ( .a(src0), .b(alusrc1), .branchop(opcode),.ALUctrl(ALUop),.branch_en(branch_en),.z(ALUout) );
ctl_unq1  my_ctl  ( .instr(instr), .jump_sel(jump_sel), .branch(branch), .memRead(memRead), .mem_to_reg(mem_to_reg), .ALUop(ALUop), .memWrite(memWrite), .ALUSrc(ALUSrc), .RegWrite(RegWrite), .RegDST(RegDST) );
//dff_unq1  d_I  ( .din(instr),    .clk, .rst, .q(instr_tmp));
//dff_unq1  d_P  ( .din(pc),       .clk, .rst, .q(pc_tmp)   );
//dff_unq1  d_S0 ( .din(src0),     .clk, .rst, .q(src0_tmp) );
//dff_unq1  d_S1 ( .din(src1),     .clk, .rst, .q(src1_tmp) );
//dff_unq1  d_M  ( .din(memRdData),.clk, .rst, .q(MRD_tmp)  );
//dff_unq1  d_MRA( .din(ALUout),   .clk, .rst, .q(memRdAddr));  
//dff_unq1  d_MRE( .din(memRead),  .clk, .rst, .q(memRdEn)  ); 
//dff_unq1  d_MWD( .din(src1_tmp), .clk, .rst, .q(memWrData)); 
//dff_unq1  d_MWA( .din(ALUout),   .clk, .rst, .q(memWrAddr)); 
//dff_unq1  d_MWE( .din(memWrite), .clk, .rst, .q(memWrEn)  ); 
//dff_unq1  d_D( .din(dst0_nxt), .clk, .rst, .q(dst0)     ); 
//dff_unq1  d_P( .din(pc_nxt1),  .clk, .rst, .q(pcNxt)    ); 

////////////////////////////////////
// Signal Assignments 
////////////////////////////////////
assign instr_se = {16'd0, instr[15:0]};
assign instr_jump = instr[25:0] << 2;//logic needed
assign opcode = instr[31:26];

////////////////////////////////////
// Muxes 
////////////////////////////////////
assign RegDST_out = RegDST ? instr[15:11] : instr[20:16];
assign alusrc1 = ALUSrc ? instr_se : src1;
assign branch_sel = branch && branch_en;
assign pc_nxt0 = branch_sel ? pc_branch : pc_4;
assign dst0 = mem_to_reg ? memRdData : ALUout;
assign pc_jr = src0;

////////////////////////////////////
// PC NXT
////////////////////////////////////
always_comb begin
	unique case (jump_sel)
	2'b00 : pcNxt = pc_nxt0;
	2'b01 : pcNxt = pc_jump;
        2'b10 : pcNxt = pc_jr;
	endcase
end

////////////////////////////////////
// Combinatorial logic 
////////////////////////////////////

assign pc_4 = pc + 4;
assign instr_se_sl2 = instr_se << 2;
assign pc_branch = instr_se_sl2 + pc_4;
assign pc_jump = {pc_4[31:28],instr_jump};
assign memRdAddr = ALUout;
assign memWrAddr = ALUout;
assign memRdEn = memRead;
assign memWrData = src1;
assign memWrEn = memWrite;


endmodule: combCore
